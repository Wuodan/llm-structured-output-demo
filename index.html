<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Structured Output Demo</title>
    <style>
      :root {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        color: #1f2933;
        background: #f9fafb;
      }

      body {
        margin: 0;
        padding: 1.5rem;
      }

      .container {
        max-width: 900px;
        margin: 0 auto 3rem;
      }

      h1 {
        margin-bottom: 0.25rem;
      }

      .subtitle {
        margin-top: 0;
        font-size: 1.1rem;
        color: #4b5563;
      }

      .intro {
        margin-bottom: 2rem;
        color: #374151;
      }

      .panel {
        background: #fff;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        padding: 1rem 1.25rem;
        margin-bottom: 1rem;
        box-shadow: 0 1px 2px rgba(15, 23, 42, 0.06);
      }

      .panel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
      }

      .panel-header h2 {
        margin: 0;
        font-size: 1.1rem;
      }

      .toggle-btn {
        background: transparent;
        border: 1px solid #94a3b8;
        border-radius: 999px;
        padding: 0.2rem 0.85rem;
        cursor: pointer;
        font-size: 0.9rem;
      }

      .section-body {
        margin-top: 0.75rem;
      }

      label {
        font-weight: 600;
        display: block;
        margin-bottom: 0.35rem;
      }

      input,
      textarea,
      select,
      button {
        font-family: inherit;
      }

      input,
      textarea,
      select {
        width: 100%;
        border: 1px solid #cbd5f5;
        border-radius: 6px;
        padding: 0.5rem 0.65rem;
        font-size: 0.95rem;
        box-sizing: border-box;
      }

      textarea {
        min-height: 140px;
        resize: vertical;
      }

      .stack {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .process-btn {
        margin-top: 0.5rem;
        padding: 0.6rem 1.2rem;
        background: #2563eb;
        color: #fff;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 1rem;
      }

      .process-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .status {
        margin-top: 0.5rem;
        font-size: 0.9rem;
      }

      .status[data-status="error"] {
        color: #b91c1c;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 0.5rem;
      }

      th,
      td {
        border: 1px solid #d1d5db;
        padding: 0.5rem;
        text-align: left;
        vertical-align: top;
      }

      th {
        background: #f3f4f6;
      }

      @media (max-width: 600px) {
        body {
          padding: 1rem;
        }

        .panel {
          padding: 1rem;
        }
      }
    </style>
  </head>
  <body>
    <main class="container">
      <header class="hero">
        <h1>Structured Output Demo</h1>
        <p class="subtitle">Turn unstructured text into JSON and a table (minimal example).</p>
        <p class="intro">
          This page calls an LLM with a system + user prompt that requests structured output (JSON).
          If the JSON is valid, it is shown below and rendered as a table.
        </p>
      </header>

      <section class="panel" data-section="explanation">
        <div class="panel-header">
          <h2>Explanation</h2>
          <button type="button" class="toggle-btn" aria-expanded="true" aria-controls="section-explanation">
            Hide
          </button>
        </div>
        <div class="section-body" id="section-explanation">
          <p>
            The prompts instruct the LLM to return <strong>only valid JSON</strong> with a stable schema so we can
            safely parse and visualize it. This keeps the flow predictable: prompt → LLM JSON → parse → table.
          </p>
        </div>
      </section>

      <section class="panel" data-section="config">
        <div class="panel-header">
          <h2>Config</h2>
          <button type="button" class="toggle-btn" aria-expanded="false" aria-controls="section-config">
            Show
          </button>
        </div>
        <div class="section-body" id="section-config">
          <p>Update the endpoint, API key, or model before sending the request. Nothing is stored.</p>
          <div class="stack">
            <label for="provider-url">LLM Provider URL</label>
            <input id="provider-url" name="provider-url" type="url" value="https://openrouter.ai/api/v1/chat/completions" />

            <label for="api-key">API Key</label>
            <input id="api-key" name="api-key" type="password" />

            <label for="model-name">Model</label>
            <input id="model-name" name="model-name" type="text" value="qwen/qwen-2.5-coder-32b-instruct:free" />
          </div>
          <div id="config-status" class="status" aria-live="polite"></div>
        </div>
      </section>

      <section class="panel" data-section="input">
        <div class="panel-header">
          <h2>Input</h2>
          <button type="button" class="toggle-btn" aria-expanded="true" aria-controls="section-input">
            Hide
          </button>
        </div>
        <div class="section-body" id="section-input">
          <p>Paste any customer message, then run the structured-output workflow.</p>
          <label for="customer-input">Customer Message</label>
          <textarea id="customer-input">
Hi Support,

I purchased the Aurora Smart Lamp (model A-200) on October 12 from your web store. It connected fine initially, but it no longer joins my Wi-Fi (2.4 GHz). I reset the lamp twice and reinstalled the mobile app. Still no luck. Could you help? My order number should be 78431-DE. If you need more info, let me know.

Thanks,
Lisa Meyer
          </textarea>
          <button id="process-button" class="process-btn" type="button">Process</button>
        </div>
      </section>

      <section class="panel" data-section="prompts">
        <div class="panel-header">
          <h2>Prompts</h2>
          <button type="button" class="toggle-btn" aria-expanded="false" aria-controls="section-prompts">
            Show
          </button>
        </div>
        <div class="section-body" id="section-prompts">
          <p>These prompts demand structured JSON so the demo can parse it deterministically.</p>
          <label for="system-prompt">System Prompt</label>
          <textarea id="system-prompt">
You are a structured-output assistant for a customer-service system.
Analyze incoming messages and return ONLY valid JSON with clearly typed fields.
Return ONLY valid JSON, with no explanations.
          </textarea>

          <label for="user-prompt">User Prompt</label>
          <textarea id="user-prompt">
Classify the customer request below and extract structured fields.

Required JSON keys:
{
  "customer_name": string,
  "issue_category": one of ["technical", "billing", "shipping", "product_question", "other"],
  "product_name": string | null,
  "product_model": string | null,
  "order_number": string | null,
  "summary": string  // short plain-text summary of the problem
}

Customer message:
          </textarea>
        </div>
      </section>

      <section class="panel" data-section="response">
        <div class="panel-header">
          <h2>Response</h2>
          <button type="button" class="toggle-btn" aria-expanded="false" aria-controls="section-response">
            Show
          </button>
        </div>
        <div class="section-body" id="section-response">
          <p>The raw model response (pretty-printed when valid JSON).</p>
          <label for="response-area">Model Response</label>
          <textarea id="response-area" readonly></textarea>
        </div>
      </section>

      <section class="panel" data-section="output">
        <div class="panel-header">
          <h2>Output</h2>
          <button type="button" class="toggle-btn" aria-expanded="true" aria-controls="section-output">
            Hide
          </button>
        </div>
        <div class="section-body" id="section-output">
          <p>When parsing succeeds, the structured fields appear in this table.</p>
          <div id="output-table-container" aria-live="polite"></div>
        </div>
      </section>
    </main>

    <script>
      const OBFUSCATE_MASK = [0x5a, 0xc3, 0x17, 0x9f, 0x4d, 0x22, 0xb7, 0x01];
      const DEFAULT_API_KEY_OBFUSCATED =
        '29a83af03f0fc13077a271ae7f1bd63563f771a67512d36368a171fe7d1a853569f323f92913d4316fa576a72c1ad2303bfb25fd7d1384376af32efc791781653ff726ae2947d6636d';

      function deobfuscate(obfHex) {
        if (typeof obfHex !== 'string') throw new TypeError('obfHex must be a hex string');
        const len = obfHex.length / 2;
        const masked = new Uint8Array(len);
        for (let i = 0; i < len; i++) masked[i] = parseInt(obfHex.substr(i * 2, 2), 16);
        const orig = new Uint8Array(len);
        for (let i = 0; i < len; i++) orig[i] = masked[i] ^ OBFUSCATE_MASK[i % OBFUSCATE_MASK.length];
        if (typeof Buffer !== 'undefined' && Buffer.from) {
          return Buffer.from(orig).toString('utf8');
        }
        return new TextDecoder().decode(orig);
      }

      // Initial open/closed state for each collapsible section.
      const SECTION_DEFAULTS = {
        explanation: true,
        config: false,
        input: true,
        prompts: false,
        response: false,
        output: true,
      };

      const OUTPUT_FIELDS = [
        { key: 'customer_name', label: 'Customer Name' },
        { key: 'issue_category', label: 'Issue Category' },
        { key: 'product_name', label: 'Product Name' },
        { key: 'product_model', label: 'Product Model' },
        { key: 'order_number', label: 'Order Number' },
        { key: 'summary', label: 'Summary' },
      ];

      document.addEventListener('DOMContentLoaded', () => {
        const elements = mapElements();
        setupSections(SECTION_DEFAULTS);
        prefillApiKey(elements.apiKey);
        elements.processButton.addEventListener('click', () => handleProcess(elements));
      });

      function mapElements() {
        return {
          providerUrl: document.getElementById('provider-url'),
          apiKey: document.getElementById('api-key'),
          model: document.getElementById('model-name'),
          systemPrompt: document.getElementById('system-prompt'),
          userPrompt: document.getElementById('user-prompt'),
          customerInput: document.getElementById('customer-input'),
          responseArea: document.getElementById('response-area'),
          tableContainer: document.getElementById('output-table-container'),
          processButton: document.getElementById('process-button'),
          status: document.getElementById('config-status'),
        };
      }

      function setupSections(defaults) {
        document.querySelectorAll('[data-section]').forEach((section) => {
          const key = section.dataset.section;
          const body = section.querySelector('.section-body');
          const toggle = section.querySelector('.toggle-btn');
          const desired = Object.prototype.hasOwnProperty.call(defaults, key) ? defaults[key] : true;
          setBodyState(body, toggle, Boolean(desired));
          toggle.addEventListener('click', () => {
            setBodyState(body, toggle, body.hidden);
          });
        });
      }

      function setBodyState(body, toggle, open) {
        body.hidden = !open;
        toggle.textContent = open ? 'Hide' : 'Show';
        toggle.setAttribute('aria-expanded', String(open));
      }

      function prefillApiKey(input) {
        try {
          input.value = deobfuscate(DEFAULT_API_KEY_OBFUSCATED);
        } catch (err) {
          input.value = '';
        }
      }

      async function handleProcess(elements) {
        updateStatus(elements, 'info', 'Sending request…');
        elements.processButton.disabled = true;
        elements.processButton.textContent = 'Processing…';
        elements.responseArea.value = '';
        renderTable(elements.tableContainer, null);

        const url = elements.providerUrl.value.trim();
        const model = elements.model.value.trim();
        const systemPrompt = elements.systemPrompt.value.trim();
        const userPrompt = elements.userPrompt.value.trim();
        const inputText = elements.customerInput.value.trim();

        const apiKeyInput = elements.apiKey.value.trim();

        const errors = [];
        if (!url) errors.push('LLM provider URL is required.');
        if (!model) errors.push('Model is required.');
        if (!apiKeyInput) errors.push('API key is required.');

        if (errors.length) {
          updateStatus(elements, 'error', errors.join(' '));
          resetButton(elements.processButton);
          return;
        }

        try {
          const response = await fetch(url, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              Authorization: `Bearer ${apiKeyInput}`,
            },
            body: JSON.stringify(
              {
                "model": model,
                messages: [
                  { role: 'system', content: systemPrompt },
                  { role: 'user', content: userPrompt },
                  { role: 'user', content: inputText }
                ]
              }
            )
          });

          const responseText = await response.text();
          if (!response.ok) {
            throw `HTTP ${response.status} ${response.statusText}\n${responseText}`;
          }

          let parsed;
          try {
            parsed = JSON.parse(responseText);
          } catch (err) {
            throw 'Failed to parse provider response JSON.';
          }

          const content = parsed?.choices?.[0]?.message?.content;
          if (!content) {
            throw 'Provider response did not include any message content.';
          }

          handleModelResponse(content.trim(), elements);
        } catch (err) {
          elements.responseArea.value = typeof err === 'string' ? err : `Network error: ${err.message}`;
          renderTable(elements.tableContainer, null);
          updateStatus(elements, 'error', 'Unable to reach the model endpoint.');
        } finally {
          resetButton(elements.processButton);
        }
      }

      function handleModelResponse(modelText, elements) {
        elements.responseArea.value = modelText;
        try {
          const parsed = JSON.parse(modelText);
          elements.responseArea.value = JSON.stringify(parsed, null, 2);
          renderTable(elements.tableContainer, parsed);
          updateStatus(elements, 'info', 'Parsed JSON successfully.');
        } catch (err) {
          renderTable(elements.tableContainer, null);
          updateStatus(elements, 'error', 'Response was not valid JSON.');
        }
      }

      // Builds a deterministic table so missing JSON keys just render empty cells.
      function renderTable(container, data) {
        container.innerHTML = '';
        if (!data || typeof data !== 'object') return;

        const table = document.createElement('table');
        const thead = document.createElement('thead');
        const headRow = document.createElement('tr');
        OUTPUT_FIELDS.forEach((field) => {
          const th = document.createElement('th');
          th.textContent = field.label;
          headRow.appendChild(th);
        });
        thead.appendChild(headRow);

        const tbody = document.createElement('tbody');
        const row = document.createElement('tr');
        OUTPUT_FIELDS.forEach((field) => {
          const td = document.createElement('td');
          const value = data[field.key];
          td.textContent = value === undefined || value === null ? '' : String(value);
          row.appendChild(td);
        });
        tbody.appendChild(row);

        table.appendChild(thead);
        table.appendChild(tbody);
        container.appendChild(table);
      }

      function updateStatus(elements, status, message) {
        elements.status.dataset.status = status;
        elements.status.textContent = message;
      }

      function resetButton(button) {
        button.disabled = false;
        button.textContent = 'Process';
      }
    </script>
  </body>
</html>
